//////////////////////////////////////////////////////////////////////////////////////////////
/*
	FSMClientFFA State machine
	
	File generated 17/05/2010 at 20:50:18
	
	Do not edit this file directly.
	Use Rapido! by Cedric Guillemet.
	
	Rapido! is licensed under GPLV2. Here is a copy of Rapido! License :
	
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; version 2 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
*/
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef FSMClientFFA_H__
#define FSMClientFFA_H__

///////////////////////////////////////////////////////////////////////////////////////////////////

#include "ZFSM.h"

#include "FSMClientRaceStart.h"

///////////////////////////////////////////////////////////////////////////////////////////////////

enum {
Type_GotSlot

};

///////////////////////////////////////////////////////////////////////////////////////////////////




/*

*/
typedef struct GotSlot
{

} GotSlot;



///////////////////////////////////////////////////////////////////////////////////////////////////

class FSMClientFFA : public ZFSM
{
public:
	FSMClientFFA()
	{
		
		mGame = NULL;
		mState = Undefined;
		EnterUndefined();
		
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Tick(float timeEllapsed);

	//////////////////////////////////////////////////////////////////////////////////////////////
	

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Handle(const GotSlot& mes)
{
	switch(mState)
	{
		case FFAAskSlot:
			HandleFFAAskSlot(mes);
			break;
		case FFAPlaying:
			HandleFFAPlaying(mes);
			break;
		case Undefined:
			HandleUndefined(mes);
			break;
	}
}



	//////////////////////////////////////////////////////////////////////////////////////////////
protected:

	enum STATE
	{
	FFAAskSlot,
FFAPlaying,
Undefined

	};

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	STATE mState;
	ZRushGame *mGame;
FSMClientRaceStart mFSMClientRaceStart;

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void SetState(STATE newState)
	{
			switch(mState)
	{
		case FFAAskSlot:
			LeaveFFAAskSlot();
			break;
		case FFAPlaying:
			LeaveFFAPlaying();
			break;
		case Undefined:
			LeaveUndefined();
			break;
	}
mState = newState;	switch(newState)
	{
		case FFAAskSlot:
			EnterFFAAskSlot();
			break;
		case FFAPlaying:
			EnterFFAPlaying();
			break;
		case Undefined:
			EnterUndefined();
			break;
	}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void TickFFAAskSlot(float timeEllapsed)
{


}
inline void TickFFAPlaying(float timeEllapsed)
{

mFSMClientRaceStart.Tick(timeEllapsed);
}
inline void TickUndefined(float timeEllapsed)
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void EnterFFAAskSlot()
{

if (mGame)
    mGame->SendNetMessage(ZNMSG_AskSlot());
}
inline void EnterFFAPlaying()
{

ZShip *pClientShip = mGame->GetClientShip();

bool bIsSoloGame = mGame->IsSoloGame();
// new sub state
switch (mGame->GetGameSet().mGameType)
{
case 0: // Raw
    //pClientShip->SetInteractionType(INTERACTION_USER_INPUT);
    mGame->EnableAllShipsControls();
    gCameraMotion.SetCameraPiloting(pClientShip->GetTransform());
    mGame->ShowHUD(true);
    mGame->AllowInGameMenu(true);
break;
case 1:// Classing Race in Solo
        mFSMClientRaceStart.mGame = mGame;
        mFSMClientRaceStart.SetState(FSMClientRaceStart::SoloPreCountDownTransition);
        mGame->ShowHUD(false);
break;
case 3: // Editor mode
    mGame->EnableAllShipsControls();
    gCameraMotion.SetCameraPiloting(pClientShip->GetTransform());
break;
}
}
inline void EnterUndefined()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void LeaveFFAAskSlot()
{


}
inline void LeaveFFAPlaying()
{


}
inline void LeaveUndefined()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void HandleFFAAskSlot(const GotSlot& mes)
{

}

void HandleFFAPlaying(const GotSlot& mes)
{
SetState(FFAPlaying);
}

void HandleUndefined(const GotSlot& mes)
{
SetState(FFAPlaying);
}


	
	//////////////////////////////////////////////////////////////////////////////////////////////
};

///////////////////////////////////////////////////////////////////////////////////////////////////

inline void FSMClientFFA::Tick(float timeEllapsed)
{
	ZFSM::Tick(timeEllapsed);
	
		switch(mState)
	{
		case FFAAskSlot:
			TickFFAAskSlot(timeEllapsed);
			break;
		case FFAPlaying:
			TickFFAPlaying(timeEllapsed);
			break;
		case Undefined:
			TickUndefined(timeEllapsed);
			break;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////

#endif

