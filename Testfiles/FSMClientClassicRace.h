//////////////////////////////////////////////////////////////////////////////////////////////
/*
	FSMClientClassicRace State machine
	
	File generated 17/05/2010 at 20:50:18
	
	Do not edit this file directly.
	Use Rapido! by Cedric Guillemet.
	
	Rapido! is licensed under GPLV2. Here is a copy of Rapido! License :
	
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; version 2 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
*/
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef FSMClientClassicRace_H__
#define FSMClientClassicRace_H__

///////////////////////////////////////////////////////////////////////////////////////////////////

#include "ZFSM.h"



///////////////////////////////////////////////////////////////////////////////////////////////////

enum {

};

///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////

class FSMClientClassicRace : public ZFSM
{
public:
	FSMClientClassicRace()
	{
		
		mGame = NULL;
		mState = Undefined;
		EnterUndefined();
		
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	void Tick(float timeEllapsed);

	//////////////////////////////////////////////////////////////////////////////////////////////
	

	//////////////////////////////////////////////////////////////////////////////////////////////
	

	//////////////////////////////////////////////////////////////////////////////////////////////
protected:

	enum STATE
	{
	Racing,
RacingOverAutopilot,
RacingOverDisplayEndInfos,
Undefined

	};

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	STATE mState;
	ZRushGame *mGame;
int mTimerEndRace;
int mNbLapsToDo;

	//////////////////////////////////////////////////////////////////////////////////////////////
	
	void SetState(STATE newState)
	{
			switch(mState)
	{
		case Racing:
			LeaveRacing();
			break;
		case RacingOverAutopilot:
			LeaveRacingOverAutopilot();
			break;
		case RacingOverDisplayEndInfos:
			LeaveRacingOverDisplayEndInfos();
			break;
		case Undefined:
			LeaveUndefined();
			break;
	}
mState = newState;	switch(newState)
	{
		case Racing:
			EnterRacing();
			break;
		case RacingOverAutopilot:
			EnterRacingOverAutopilot();
			break;
		case RacingOverDisplayEndInfos:
			EnterRacingOverDisplayEndInfos();
			break;
		case Undefined:
			EnterUndefined();
			break;
	}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void TickRacing(float timeEllapsed)
{

ZShip *pShip = mGame->GetClientShip();
if (pShip->GetCurrentLap() > mGame->GetGameSet().mNbLaps)
{
        SetState(RacingOverAutopilot);
}
}
inline void TickRacingOverAutopilot(float timeEllapsed)
{

if (OnTimer(mTimerEndRace))
{
SetState(RacingOverDisplayEndInfos);
}
}
inline void TickRacingOverDisplayEndInfos(float timeEllapsed)
{


}
inline void TickUndefined(float timeEllapsed)
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void EnterRacing()
{

mNbLapsToDo = mGame->GetGameSet().mNbLaps;
}
inline void EnterRacingOverAutopilot()
{

mTimerEndRace = NewTimer(5.f);

ZShip *pShip = mGame->GetClientShip();
pShip->SetInteractionType(INTERACTION_IA);
pShip->EnableLapTimeComputation(false);
mGame->ShowHUD(false);
}
inline void EnterRacingOverDisplayEndInfos()
{

GProtoGui->ShowEndResult();
mGame->AllowInGameMenu(false);
gCameraMotion.SetCameraTransitionedObserver(mGame->GetClientShip());
}
inline void EnterUndefined()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	inline void LeaveRacing()
{


}
inline void LeaveRacingOverAutopilot()
{

RemoveTimer(mTimerEndRace);
}
inline void LeaveRacingOverDisplayEndInfos()
{


}
inline void LeaveUndefined()
{


}

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	
	
	
	//////////////////////////////////////////////////////////////////////////////////////////////
};

///////////////////////////////////////////////////////////////////////////////////////////////////

inline void FSMClientClassicRace::Tick(float timeEllapsed)
{
	ZFSM::Tick(timeEllapsed);
	
		switch(mState)
	{
		case Racing:
			TickRacing(timeEllapsed);
			break;
		case RacingOverAutopilot:
			TickRacingOverAutopilot(timeEllapsed);
			break;
		case RacingOverDisplayEndInfos:
			TickRacingOverDisplayEndInfos(timeEllapsed);
			break;
		case Undefined:
			TickUndefined(timeEllapsed);
			break;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////

#endif

